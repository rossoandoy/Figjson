// „Éñ„É©„Ç¶„Ç∂Áî®„ÅÆFigma to eDocument Converter
class FigmaToEDocumentConverter {
    constructor() {
        this.pointToMm = 0.352778; // 1 point = 0.352778 mm
        this.paperSizes = {
            'A4': { 
                portrait: { width: 210, height: 297 },
                landscape: { width: 297, height: 210 }
            },
            'A3': { 
                portrait: { width: 297, height: 420 },
                landscape: { width: 420, height: 297 }
            },
            'B4': { 
                portrait: { width: 257, height: 364 },
                landscape: { width: 364, height: 257 }
            },
            'B5': { 
                portrait: { width: 182, height: 257 },
                landscape: { width: 257, height: 182 }
            },
            'Letter': { 
                portrait: { width: 216, height: 279 },
                landscape: { width: 279, height: 216 }
            },
            'Legal': { 
                portrait: { width: 216, height: 356 },
                landscape: { width: 356, height: 216 }
            }
        };
    }

    convertFigmaToEDocument(figmaData, paperType = 'A4', orientation = 'portrait', scaleFactor = 1.0) {
        const paperSize = this.paperSizes[paperType][orientation];
        
        const eDocumentData = {
            panels: [{
                index: 0,
                name: 1,
                paperType: paperType,
                height: paperSize.height,
                width: paperSize.width,
                paperHeader: 20,
                paperFooter: 566.9927622683529,
                printElements: [],
                paperNumberLeft: 811,
                paperNumberTop: 573,
                paperNumberDisabled: true,
                paperNumberContinue: false,
                fontFamily: "sans-serif",
                overPrintOptions: {
                    content: "",
                    opacity: 0.7,
                    type: 1
                },
                watermarkOptions: {
                    content: "",
                    fillStyle: "rgba(184, 184, 184, 0.3)",
                    fontSize: "14px",
                    rotate: 25,
                    width: 200,
                    height: 200,
                    timestamp: false,
                    format: "YYYY-MM-DD HH:mm"
                }
            }]
        };

        // Figma„ÅÆ„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
        this.figmaWidth = figmaData.width || 1024;
        this.figmaHeight = figmaData.height || 724;
        this.scaleFactor = scaleFactor;
        this.targetPaperSize = paperSize;
        this.debugInfo = []; // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„ÇíÊ†ºÁ¥ç
        this.placedElements = []; // ÈÖçÁΩÆÊ∏à„ÅøË¶ÅÁ¥†„ÅÆ‰ΩçÁΩÆÁÆ°ÁêÜ

        // textContent„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØpath„Éô„Éº„ÇπÂ§âÊèõ„ÄÅ„Å™„ÅÑÂ†¥Âêà„ÅØÂæìÊù•„ÅÆÂ§âÊèõ
        if (figmaData.textContent && Array.isArray(figmaData.textContent)) {
            console.log('üéØ path„Éô„Éº„ÇπÂ§âÊèõ„Çí‰ΩøÁî®„Åó„Åæ„Åô');
            this.processWithTextContent(figmaData, eDocumentData.panels[0].printElements);
        } else {
            console.log('üìÑ ÂæìÊù•„ÅÆÈöéÂ±§Êé¢Á¥¢Â§âÊèõ„Çí‰ΩøÁî®„Åó„Åæ„Åô');
            this.processNode(figmaData, eDocumentData.panels[0].printElements);
        }
        
        // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„Çí„Ç≥„É≥„ÇΩ„Éº„É´„Å´Âá∫Âäõ
        console.log('üîç Figma‚ÜíeDocument Â§âÊèõ„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±:', this.debugInfo);
        
        return eDocumentData;
    }

    processWithTextContent(figmaData, printElements) {
        console.log(`üìù textContentÈÖçÂàó„Åã„Çâ ${figmaData.textContent.length} ÂÄã„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàË¶ÅÁ¥†„ÇíÂá¶ÁêÜ„Åó„Åæ„Åô`);
        
        // path„Åß„Éé„Éº„Éâ„ÇíË¶ã„Å§„Åë„Çã„Åü„ÇÅ„ÅÆ„Éû„ÉÉ„Éó„Çí‰ΩúÊàê
        const nodeMap = this.buildNodeMap(figmaData);
        
        // textContent„ÅÆÂêÑË¶ÅÁ¥†„ÇíÂá¶ÁêÜ
        figmaData.textContent.forEach((textItem, index) => {
            // path„Åã„ÇâË©≤ÂΩì„Éé„Éº„Éâ„ÇíÊ§úÁ¥¢
            const node = this.findNodeByPath(textItem.path, nodeMap);
            
            if (node) {
                // path„Éô„Éº„Çπ„Åß„Çà„ÇäÊ≠£Á¢∫„Å™Â∫ßÊ®ô„ÇíË®àÁÆó
                const position = this.calculatePathBasedPosition(textItem.path, node, nodeMap);
                
                this.convertTextNodeWithPath(node, textItem, printElements, position.x, position.y);
                
                // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„ÇíË®òÈå≤
                this.debugInfo.push({
                    type: 'PATH_BASED_TEXT',
                    name: textItem.name,
                    path: textItem.path,
                    text: textItem.text.substring(0, 50) + (textItem.text.length > 50 ? '...' : ''),
                    figmaSize: { width: node.width, height: node.height },
                    figmaFont: node.fontSize,
                    calculatedPosition: position,
                    eDocumentPosition: { 
                        left: this.convertPosition(position.x), 
                        top: this.convertPosition(position.y) 
                    }
                });
            } else {
                console.warn(`‚ö†Ô∏è path„Å´ÂØæÂøú„Åô„Çã„Éé„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${textItem.path}`);
                this.debugInfo.push({
                    type: 'PATH_NOT_FOUND',
                    name: textItem.name,
                    path: textItem.path,
                    text: textItem.text.substring(0, 50) + (textItem.text.length > 50 ? '...' : ''),
                    reason: 'path„Å´ÂØæÂøú„Åô„Çã„Éé„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ'
                });
            }
        });
    }

    buildNodeMap(node, path = '', map = new Map()) {
        // ÁèæÂú®„ÅÆ„Éé„Éº„Éâ„Çí„Éû„ÉÉ„Éó„Å´ËøΩÂä†
        if (node.name) {
            const currentPath = path ? `${path}/${node.name}` : node.name;
            map.set(currentPath, node);
        }
        
        // Â≠ê„Éé„Éº„Éâ„ÇíÂÜçÂ∏∞ÁöÑ„Å´Âá¶ÁêÜ
        if (node.children && Array.isArray(node.children)) {
            node.children.forEach(child => {
                const childPath = path ? `${path}/${node.name || 'unnamed'}` : (node.name || 'unnamed');
                this.buildNodeMap(child, childPath, map);
            });
        }
        
        return map;
    }

    findNodeByPath(targetPath, nodeMap) {
        // path„ÅÆÂΩ¢Âºè: "Figma design - [„Éï„Ç°„Ç§„É´Âêç].../Root/Groups/[Ë¶ÅÁ¥†Âêç]"
        // „É´„Éº„Éà„Éï„Ç°„Ç§„É´ÂêçÈÉ®ÂàÜ„ÇíÈô§Âéª„Åó„Å¶Ê≠£Ë¶èÂåñ
        const normalizedPath = targetPath.split('/').slice(1).join('/'); // "Root/Groups/[Ë¶ÅÁ¥†Âêç]"
        
        // ÂÆåÂÖ®‰∏ÄËá¥„ÇíË©¶Ë°å
        if (nodeMap.has(normalizedPath)) {
            return nodeMap.get(normalizedPath);
        }
        
        // ÈÉ®ÂàÜ‰∏ÄËá¥„ÇíË©¶Ë°åÔºàÊúÄÂæå„ÅÆË¶ÅÁ¥†Âêç„ÅßÊ§úÁ¥¢Ôºâ
        const elementName = targetPath.split('/').pop();
        for (const [mapPath, node] of nodeMap.entries()) {
            if (mapPath.endsWith(`/${elementName}`) || mapPath === elementName) {
                return node;
            }
        }
        
        return null;
    }

    calculatePathBasedPosition(path, node, nodeMap) {
        // path„ÅÆÈöéÂ±§„Åã„Çâ‰ΩçÁΩÆ„ÇíË®àÁÆó
        const pathSegments = path.split('/').slice(1); // „Éï„Ç°„Ç§„É´Âêç„ÇíÈô§Âéª
        const elementName = pathSegments[pathSegments.length - 1];
        
        // A4ÊñáÊõ∏„ÅÆÂÆüÈöõ„ÅÆ„É¨„Ç§„Ç¢„Ç¶„Éà„Å´Âü∫„Å•„ÅèÂ∫ßÊ®ôË®àÁÆóÔºàmm„Éô„Éº„ÇπÔºâ
        let x = 40; // Âü∫Êú¨Â∑¶„Éû„Éº„Ç∏„É≥ÔºàmmÔºâ
        let y = 40; // Âü∫Êú¨‰∏ä„Éû„Éº„Ç∏„É≥ÔºàmmÔºâ
        
        console.log(`üéØ Ë¶ÅÁ¥†ÈÖçÁΩÆ: "${elementName}"`);
        
        // „Éâ„Ç≠„É•„É°„É≥„ÉàÊßãÈÄ†„Å´Âü∫„Å•„ÅèË©≥Á¥∞ÈÖçÁΩÆ
        
        // === „Éò„ÉÉ„ÉÄ„Éº„Ç®„É™„Ç¢ ===
        if (elementName.includes('ÊãÖÂΩìËÄÖ') || elementName.match(/^[A-Z]{2,}/) || this.isHeaderElement(elementName)) {
            x = 200; y = 15; // Âè≥‰∏ä„Éò„ÉÉ„ÉÄ„Éº
        }
        
        // === „É°„Ç§„É≥„Çø„Ç§„Éà„É´ ===
        else if (this.isTitleElement(elementName)) {
            x = 50; y = 50; // „Çª„É≥„Çø„ÉºÂØÑ„Çä„Çø„Ç§„Éà„É´
        } else if (this.isSubtitleElement(elementName)) {
            x = 50; y = 75; // „Çµ„Éñ„Çø„Ç§„Éà„É´
        }
        
        // === Â•ëÁ¥ÑËÄÖÊÉÖÂ†±„Éñ„É≠„ÉÉ„ÇØ ===
        else if (this.isContractorElement(elementName)) {
            x = 40; y = 100; // Â∑¶ÂÅ¥„É©„Éô„É´
        } else if (this.isDateElement(elementName)) {
            x = 120; y = 100; // Êó•‰ªòÂÖ•ÂäõÊ¨Ñ
        }
        
        // === ÂÄã‰∫∫ÊÉÖÂ†±„ÉÜ„Éº„Éñ„É´„Éò„ÉÉ„ÉÄ„Éº ===
        else if (this.isPersonalInfoElement(elementName)) {
            const infoIndex = this.getPersonalInfoIndex(elementName);
            x = 40 + (infoIndex > 0 ? 160 : 0); 
            y = 140 + (infoIndex * 30); // „ÉÜ„Éº„Éñ„É´Ë°å
        }
        
        // === „Çª„ÇØ„Ç∑„Éß„É≥„Éò„ÉÉ„ÉÄ„Éº ===
        else if (this.isSectionHeaderElement(elementName)) {
            x = 40; y = 210; // „Çª„ÇØ„Ç∑„Éß„É≥„Çø„Ç§„Éà„É´
        } else if (this.isSectionDescriptionElement(elementName)) {
            x = 150; y = 210; // Ë™¨ÊòéÊñá
        }
        
        // === „Ç≥„É≥„ÉÜ„É≥„ÉÑ„Çª„ÇØ„Ç∑„Éß„É≥ ===
        else if (this.isContentSectionElement(elementName)) {
            x = 40; y = 240; // „Çª„ÇØ„Ç∑„Éß„É≥„Çø„Ç§„Éà„É´
        }
        
        // === Ë≤ªÁî®„ÉªÈáëÈ°ç„Çª„ÇØ„Ç∑„Éß„É≥ ===
        else if (this.isCostElement(elementName)) {
            x = 40; y = 350; // Ë≤ªÁî®„Çª„ÇØ„Ç∑„Éß„É≥
        }
        
        // === Âè≥ÂÅ¥Ë™¨Êòé„Ç®„É™„Ç¢ (GroupsË¶ÅÁ¥†) ===
        else if (pathSegments.includes('Groups') || this.isRightPanelElement(elementName)) {
            // Âè≥ÂÅ¥Ë™¨Êòé„Éë„Éç„É´„ÅÆÈÖçÁΩÆ
            x = 300; // Âè≥ÂÅ¥ÈñãÂßã‰ΩçÁΩÆ
            
            const rightPanelY = this.calculateRightPanelY(elementName);
            y = rightPanelY;
        }
        
        // === „ÉÜ„Ç≠„Çπ„Éà„Çø„Ç§„ÉóÂà•Âá¶ÁêÜ ===
        else if (node.characters || (node.height && node.height > 40)) {
            // Èï∑„ÅÑ„ÉÜ„Ç≠„Çπ„Éà„Ç≥„É≥„ÉÜ„É≥„ÉÑ
            x = 40;
            y = 400 + (this.simpleHash(elementName) % 8) * 25;
        }
        
        // === „Åù„ÅÆ‰ªñË¶ÅÁ¥†„ÅÆ„Éá„Éï„Ç©„É´„ÉàÈÖçÁΩÆ ===
        else {
            // Âü∫Êú¨ÁöÑ„Å™Â∑¶„Ç´„É©„É†ÈÖçÁΩÆ
            const hashOffset = this.simpleHash(elementName) % 10;
            x = 40 + (hashOffset % 3) * 15;
            y = 300 + hashOffset * 20;
        }
        
        // === Â¢ÉÁïåË™øÊï¥ ===
        // A4„Çµ„Ç§„Ç∫ÂÜÖ„Å´Âèé„ÇÅ„ÇãÔºà210mm x 297mm„ÄÅ„Éû„Éº„Ç∏„É≥ËÄÉÊÖÆÔºâ
        const maxX = 180; // Âè≥„Éû„Éº„Ç∏„É≥ËÄÉÊÖÆ
        const maxY = 280; // ‰∏ã„Éû„Éº„Ç∏„É≥ËÄÉÊÖÆ
        
        x = Math.max(20, Math.min(x, maxX));
        y = Math.max(20, Math.min(y, maxY));
        
        console.log(`üìç ÊúÄÁµÇÂ∫ßÊ®ô: (${x}, ${y})`);
        
        return { x, y };
    }

    isHeaderElement(elementName) {
        // „Éò„ÉÉ„ÉÄ„ÉºË¶ÅÁ¥†„ÅÆÊ±éÁî®ÁöÑ„Å™Âà§ÂÆö
        const headerPatterns = [
            /‰ºöÁ§æ/, /‰ºÅÊ•≠/, /Ê≥ï‰∫∫/, /ÁµÑÁπî/, /Âõ£‰Ωì/,
            /ÊãÖÂΩì/, /Ë≤¨‰ªª/, /ÈÄ£Áµ°/, /Á™ìÂè£/,
            /logo/i, /header/i, /top/i
        ];
        return headerPatterns.some(pattern => pattern.test(elementName));
    }

    isTitleElement(elementName) {
        // „Çø„Ç§„Éà„É´Ë¶ÅÁ¥†„ÅÆÊ±éÁî®ÁöÑ„Å™Âà§ÂÆö
        const titlePatterns = [
            /„Å´„Å§„ÅÑ„Å¶/, /Êõ∏/, /Ë°®/, /Á•®/, /Ë®º/, /Êõ∏Èù¢/,
            /title/i, /heading/i, /main/i
        ];
        return titlePatterns.some(pattern => pattern.test(elementName));
    }

    isSubtitleElement(elementName) {
        // „Çµ„Éñ„Çø„Ç§„Éà„É´Ë¶ÅÁ¥†„ÅÆÊ±éÁî®ÁöÑ„Å™Âà§ÂÆö
        const subtitlePatterns = [
            /Ê≥ï/, /Ë¶èÁ¥Ñ/, /Êù°È†Ö/, /Ê¶ÇË¶Å/, /Ë™¨Êòé/,
            /subtitle/i, /sub/i, /description/i
        ];
        return subtitlePatterns.some(pattern => pattern.test(elementName));
    }

    isContractorElement(elementName) {
        // Â•ëÁ¥ÑËÄÖ„ÉªÈ°ßÂÆ¢ÊÉÖÂ†±Ë¶ÅÁ¥†„ÅÆÂà§ÂÆö
        const contractorPatterns = [
            /Â•ëÁ¥ÑËÄÖ/, /È°ßÂÆ¢/, /„ÅäÂÆ¢/, /Áî≥Ëæº/, /‰æùÈ†ºËÄÖ/,
            /customer/i, /client/i, /contractor/i
        ];
        return contractorPatterns.some(pattern => pattern.test(elementName));
    }

    isDateElement(elementName) {
        // Êó•‰ªòË¶ÅÁ¥†„ÅÆÂà§ÂÆö
        const datePatterns = [
            /Âπ¥.*Êúà.*Êó•/, /Êó•‰ªò/, /Âπ¥ÊúàÊó•/, /date/i, /ÊôÇÂàª/, /time/i
        ];
        return datePatterns.some(pattern => pattern.test(elementName));
    }

    isPersonalInfoElement(elementName) {
        // ÂÄã‰∫∫ÊÉÖÂ†±Ë¶ÅÁ¥†„ÅÆÂà§ÂÆö
        const personalPatterns = [
            /ÂêçÂâç/, /Ê∞èÂêç/, /„Ç´„Éä/, /Â≠¶Âπ¥/, /Âπ¥ÈΩ¢/, /‰ΩèÊâÄ/, /ÈõªË©±/,
            /name/i, /age/i, /address/i, /phone/i
        ];
        return personalPatterns.some(pattern => pattern.test(elementName));
    }

    getPersonalInfoIndex(elementName) {
        // ÂÄã‰∫∫ÊÉÖÂ†±Ë¶ÅÁ¥†„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÂèñÂæóÔºà„ÉÜ„Éº„Éñ„É´ÈÖçÁΩÆÁî®Ôºâ
        if (elementName.includes('„Ç´„Éä') || elementName.includes('kana')) return 0;
        if (elementName.includes('ÂêçÂâç') || elementName.includes('Ê∞èÂêç') || elementName.includes('name')) return 1;
        if (elementName.includes('Â≠¶Âπ¥') || elementName.includes('Âπ¥ÈΩ¢') || elementName.includes('age')) return 2;
        return 0;
    }

    isSectionHeaderElement(elementName) {
        // „Çª„ÇØ„Ç∑„Éß„É≥„Éò„ÉÉ„ÉÄ„ÉºË¶ÅÁ¥†„ÅÆÂà§ÂÆö
        const sectionPatterns = [
            /Â•ëÁ¥Ñ/, /ËøΩÂä†/, /Â§âÊõ¥/, /Êñ∞Ë¶è/, /Êõ¥Êñ∞/,
            /section/i, /header/i, /title/i
        ];
        return sectionPatterns.some(pattern => pattern.test(elementName));
    }

    isSectionDescriptionElement(elementName) {
        // „Çª„ÇØ„Ç∑„Éß„É≥Ë™¨ÊòéË¶ÅÁ¥†„ÅÆÂà§ÂÆö
        return elementName.includes('Â†¥Âêà') || elementName.includes('„Å´„Å§„ÅÑ„Å¶') || 
               elementName.includes('Ë™¨Êòé') || /description/i.test(elementName);
    }

    isContentSectionElement(elementName) {
        // „Ç≥„É≥„ÉÜ„É≥„ÉÑ„Çª„ÇØ„Ç∑„Éß„É≥Ë¶ÅÁ¥†„ÅÆÂà§ÂÆö
        const contentPatterns = [
            /ÂÜÖÂÆπ/, /Ë©≥Á¥∞/, /È†ÖÁõÆ/, /„É™„Çπ„Éà/, /‰∏ÄË¶ß/,
            /content/i, /detail/i, /item/i, /list/i
        ];
        return contentPatterns.some(pattern => pattern.test(elementName));
    }

    isCostElement(elementName) {
        // Ë≤ªÁî®„ÉªÈáëÈ°çË¶ÅÁ¥†„ÅÆÂà§ÂÆö
        const costPatterns = [
            /Ë≤ªÁî®/, /ÊñôÈáë/, /ÈáëÈ°ç/, /‰æ°Ê†º/, /‰ª£Èáë/, /Ë´ãÊ±Ç/,
            /cost/i, /price/i, /fee/i, /amount/i, /bill/i
        ];
        return costPatterns.some(pattern => pattern.test(elementName));
    }

    isRightPanelElement(elementName) {
        // Âè≥ÂÅ¥„Éë„Éç„É´Ë¶ÅÁ¥†„ÅÆÂà§ÂÆö
        const rightPanelPatterns = [
            /Ëß£Èô§/, /Â§âÊõ¥/, /ÊîØÊâï/, /ÊñπÊ≥ï/, /„Ç™„Éï/, /„Åù„ÅÆ‰ªñ/, /ÂõûÁõÆ/, /ÊåØÊõø/, /ÂÜÖË®≥/,
            /cancellation/i, /payment/i, /method/i, /change/i, /other/i
        ];
        return rightPanelPatterns.some(pattern => pattern.test(elementName));
    }

    calculateRightPanelY(elementName) {
        // Âè≥ÂÅ¥„Éë„Éç„É´Ë¶ÅÁ¥†„ÅÆÁ∏¶‰ΩçÁΩÆ„ÇíË®àÁÆó
        if (elementName.includes('Ëß£Èô§') || elementName.includes('cancel')) return 120;
        if (elementName.includes('ÊîØÊâï') || elementName.includes('payment')) return 160;
        if (elementName.includes('Â§âÊõ¥') || elementName.includes('change')) return 200;
        if (elementName.includes('„Åù„ÅÆ‰ªñ') || elementName.includes('other')) return 240;
        if (elementName.includes('ÂõûÁõÆ') || elementName.includes('ÂõûÊï∞')) return 280;
        if (elementName.includes('ÊåØÊõø') || elementName.includes('ÂÜÖË®≥')) return 320;
        
        // „Éá„Éï„Ç©„É´„ÉàÔºö„Éè„ÉÉ„Ç∑„É•„Éô„Éº„ÇπÈÖçÁΩÆ
        const groupIndex = this.simpleHash(elementName) % 12;
        return 120 + (groupIndex * 20);
    }

    simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 32bitÊï¥Êï∞„Å´Â§âÊèõ
        }
        return Math.abs(hash);
    }

    convertTextNodeWithPath(node, textItem, printElements, absoluteX, absoluteY) {
        // Âü∫Êú¨ÁöÑ„Å™convertTextNode„Å®Âêå„ÅòÂá¶ÁêÜ„Å†„Åå„ÄÅtextItem.text„Çí‰ΩøÁî®
        let elementWidth = this.convertSize(node.width || 80);
        let elementHeight = this.convertSize(node.height || 12);
        
        const maxWidth = this.targetPaperSize.width - 40;
        const maxHeight = this.targetPaperSize.height - 60;
        
        elementWidth = Math.min(elementWidth, maxWidth * 0.9);
        elementHeight = Math.min(elementHeight, Math.max(15, maxHeight * 0.15));
        
        const adjustedPosition = this.findNonOverlappingPosition(
            this.convertPosition(absoluteX),
            this.convertPosition(absoluteY),
            elementWidth,
            elementHeight
        );

        const element = {
            options: {
                left: adjustedPosition.x,
                top: adjustedPosition.y,
                height: elementHeight,
                width: elementWidth,
                borderWidth: "0.75",
                fontSize: this.convertFontSize(node.fontSize || 12),
                title: this.sanitizeText(textItem.text || textItem.name || "„ÉÜ„Ç≠„Çπ„Éà"), // textItem.text„ÇíÂÑ™ÂÖà‰ΩøÁî®
                coordinateSync: false,
                widthHeightSync: false,
                letterSpacing: this.convertLetterSpacing(node.letterSpacing),
                contentPaddingLeft: 0,
                contentPaddingTop: 0,
                contentPaddingRight: 0,
                contentPaddingBottom: 0,
                qrCodeLevel: 0,
                textContentVerticalAlign: this.convertVerticalAlign(node.textAlignVertical),
                right: adjustedPosition.x + elementWidth,
                bottom: adjustedPosition.y + elementHeight,
                vCenter: adjustedPosition.x + elementWidth / 2,
                hCenter: adjustedPosition.y + elementHeight / 2
            },
            printElementType: {
                title: "„ÉÜ„Ç≠„Çπ„Éà",
                type: "text"
            }
        };

        // „Çπ„Çø„Ç§„É´Ë®≠ÂÆöÔºàÊó¢Â≠ò„ÅÆconvertTextNode„Å®Âêå„ÅòÔºâ
        if (node.fontWeight >= 600) {
            element.options.fontWeight = "bold";
        }

        if (node.textAlignHorizontal) {
            element.options.textAlign = this.convertTextAlign(node.textAlignHorizontal);
        }

        if (node.fills && node.fills[0] && node.fills[0].color) {
            element.options.color = this.convertColor(node.fills[0].color);
        }

        if (node.backgroundColor) {
            element.options.backgroundColor = node.backgroundColor;
        }

        if (node.strokes && node.strokes.length > 0) {
            element.options.borderLeft = "solid";
            element.options.borderTop = "solid";
            element.options.borderRight = "solid";
            element.options.borderBottom = "solid";
        }

        // ÈÖçÁΩÆ„Åó„ÅüË¶ÅÁ¥†„ÅÆÊÉÖÂ†±„ÇíË®òÈå≤
        this.placedElements.push({
            x: adjustedPosition.x,
            y: adjustedPosition.y,
            width: elementWidth,
            height: elementHeight
        });

        printElements.push(element);
    }

    processNode(node, printElements, layoutInfo = { x: 0, y: 0, flowDirection: 'vertical' }) {
        if (!node) return;

        // „É¨„Ç§„Ç¢„Ç¶„ÉàÊÉÖÂ†±„ÇíË®àÁÆó
        const currentLayout = this.calculateLayout(node, layoutInfo);

        // „Éé„Éº„ÉâËá™‰Ωì„ÇíÂá¶ÁêÜ
        if (this.isTextNode(node)) {
            this.convertTextNode(node, printElements, currentLayout.x, currentLayout.y);
            
            // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„ÇíË®òÈå≤
            this.debugInfo.push({
                type: 'TEXT',
                name: node.name || 'Unnamed',
                figmaSize: { width: node.width, height: node.height },
                figmaFont: node.fontSize,
                estimatedPosition: { x: currentLayout.x, y: currentLayout.y },
                eDocumentPosition: { 
                    left: this.convertPosition(currentLayout.x), 
                    top: this.convertPosition(currentLayout.y) 
                }
            });
        } else if (this.isImageOrShapeNode(node) && !this.shouldSkipImageNode(node)) {
            this.convertImageOrShapeNode(node, printElements, currentLayout.x, currentLayout.y);
            
            // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„ÇíË®òÈå≤
            this.debugInfo.push({
                type: node.type,
                name: node.name || 'Unnamed',
                figmaSize: { width: node.width, height: node.height },
                estimatedPosition: { x: currentLayout.x, y: currentLayout.y },
                eDocumentPosition: { 
                    left: this.convertPosition(currentLayout.x), 
                    top: this.convertPosition(currentLayout.y) 
                }
            });
        } else if (this.shouldSkipImageNode(node)) {
            // „Çπ„Ç≠„ÉÉ„Éó„Åï„Çå„ÅüÁîªÂÉèË¶ÅÁ¥†„Çí„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„Å´Ë®òÈå≤
            this.debugInfo.push({
                type: 'SKIPPED_IMAGE',
                name: node.name || 'Unnamed',
                reason: 'Meaningless image element (type:RECTANGLE, name:Image with imageHash)',
                figmaSize: { width: node.width, height: node.height },
                imageHash: this.getImageHash(node)
            });
        }

        // Â≠ê„Éé„Éº„Éâ„ÇíÂÜçÂ∏∞ÁöÑ„Å´Âá¶ÁêÜ
        if (node.children && Array.isArray(node.children)) {
            let childX = currentLayout.x;
            let childY = currentLayout.y;
            
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                
                // Â≠êË¶ÅÁ¥†„ÅÆ„É¨„Ç§„Ç¢„Ç¶„ÉàÊÉÖÂ†±„ÇíË®àÁÆó
                const childLayout = {
                    x: childX,
                    y: childY,
                    flowDirection: node.layoutMode === 'HORIZONTAL' ? 'horizontal' : 'vertical'
                };

                this.processNode(child, printElements, childLayout);

                // Ê¨°„ÅÆÂ≠êË¶ÅÁ¥†„ÅÆ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞
                if (node.layoutMode === 'HORIZONTAL') {
                    childX += (child.width || 0) + 10; // 10pxÈñìÈöî
                } else {
                    childY += (child.height || 0) + 5; // 5pxÈñìÈöî
                }
            }
        }
    }

    calculateLayout(node, parentLayout) {
        // „Éï„É¨„Éº„É†„Çø„Ç§„Éó„Åî„Å®„Å´Áï∞„Å™„Çã„É¨„Ç§„Ç¢„Ç¶„ÉàË®àÁÆó
        if (node.type === 'FRAME') {
            return this.calculateFrameLayout(node, parentLayout);
        }
        
        // „ÉÜ„Ç≠„Çπ„Éà„ÇÑÁîªÂÉèË¶ÅÁ¥†„ÅÆÂ†¥Âêà
        return {
            x: parentLayout.x,
            y: parentLayout.y
        };
    }

    calculateFrameLayout(frame, parentLayout) {
        // „Éï„É¨„Éº„É†Âêç„Å´Âü∫„Å•„ÅèÊé®ÂÆö„É¨„Ç§„Ç¢„Ç¶„Éà
        const frameName = frame.name.toLowerCase();
        
        // „Éò„ÉÉ„ÉÄ„ÉºÈ†òÂüü„ÅÆÊé®ÂÆö
        if (frameName.includes('header') || frameName.includes('top')) {
            return {
                x: parentLayout.x,
                y: parentLayout.y
            };
        }
        
        // „Çµ„Ç§„Éâ„Éê„ÉºÈ†òÂüü„ÅÆÊé®ÂÆöÔºàÂè≥ÂÅ¥Ôºâ
        if (frameName.includes('groups') && frame.width < this.figmaWidth * 0.7) {
            return {
                x: parentLayout.x + (this.figmaWidth - frame.width),
                y: parentLayout.y
            };
        }
        
        // „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑÈ†òÂüü„ÅÆÊé®ÂÆö
        if (frameName.includes('text') || frameName.includes('content')) {
            return {
                x: parentLayout.x + 20, // Â∑¶„Éû„Éº„Ç∏„É≥
                y: parentLayout.y + 20  // ‰∏ä„Éû„Éº„Ç∏„É≥
            };
        }
        
        // „Éá„Éï„Ç©„É´„Éà
        return {
            x: parentLayout.x,
            y: parentLayout.y
        };
    }

    isTextNode(node) {
        return node.type === 'TEXT' && node.characters;
    }

    isImageOrShapeNode(node) {
        return ['RECTANGLE', 'ELLIPSE', 'POLYGON', 'VECTOR', 'IMAGE'].includes(node.type);
    }

    shouldSkipImageNode(node) {
        // type:RECTANGLE„Åßname:Image„ÅØÊÉÖÂ†±„Åå„Å™„ÅÑÔºàimageHash„Åå„ÅÇ„Å£„Å¶„ÇÇÁîªÂÉè„ÅÆ„Ç§„É≥„Éù„Éº„Éà„ÅØ„Åß„Åç„Å™„ÅÑÔºâ
        // „Åü„ÇÅ„ÄÅÈô§Â§ñ„Åô„Çã
        if (node.type === 'RECTANGLE' && 
            node.name && 
            node.name.toLowerCase() === 'image' &&
            this.getImageHash(node)) {
            return true;
        }
        
        // ÈùûÂ∏∏„Å´Â∞è„Åï„Å™ÁîªÂÉèË¶ÅÁ¥†ÔºàË£ÖÈ£æÁöÑ„Å™„Ç¢„Ç§„Ç≥„É≥„Å™„Å©Ôºâ„ÇÇÈô§Â§ñ
        if (node.type === 'RECTANGLE' && 
            this.getImageHash(node) &&
            node.width && node.height &&
            node.width < 20 && node.height < 20) {
            return true;
        }
        
        return false;
    }

    getImageHash(node) {
        if (node.fills && Array.isArray(node.fills)) {
            for (const fill of node.fills) {
                if (fill.type === 'IMAGE' && fill.imageHash) {
                    return fill.imageHash;
                }
            }
        }
        return null;
    }

    convertTextNode(node, printElements, absoluteX, absoluteY) {
        // ÈÅ©Âàá„Å™„Çµ„Ç§„Ç∫„ÇíË®àÁÆó
        let elementWidth = this.convertSize(node.width || 80);
        let elementHeight = this.convertSize(node.height || 12);
        
        // Áî®Á¥ô„Çµ„Ç§„Ç∫„Å´Âèé„Åæ„Çã„Çà„ÅÜ„Å´Ë™øÊï¥Ôºà„Çà„ÇäÂé≥ÂØÜ„Å™Âà∂Á¥ÑÔºâ
        const maxWidth = this.targetPaperSize.width - 40; // 20mm„Éû„Éº„Ç∏„É≥√ó2
        const maxHeight = this.targetPaperSize.height - 60; // 30mm„Éû„Éº„Ç∏„É≥√ó2
        
        // „ÉÜ„Ç≠„Çπ„ÉàË¶ÅÁ¥†„ÅÆÈÅ©Âàá„Å™„Çµ„Ç§„Ç∫Âà∂Èôê
        elementWidth = Math.min(elementWidth, maxWidth * 0.9);
        elementHeight = Math.min(elementHeight, Math.max(15, maxHeight * 0.15));
        
        // Ë°ùÁ™ÅÂõûÈÅø‰ΩçÁΩÆ„ÇíË®àÁÆó
        const adjustedPosition = this.findNonOverlappingPosition(
            this.convertPosition(absoluteX),
            this.convertPosition(absoluteY),
            elementWidth,
            elementHeight
        );

        const element = {
            options: {
                left: adjustedPosition.x,
                top: adjustedPosition.y,
                height: elementHeight,
                width: elementWidth,
                borderWidth: "0.75",
                fontSize: this.convertFontSize(node.fontSize || 12),
                title: this.sanitizeText(node.characters || node.name || "„ÉÜ„Ç≠„Çπ„Éà"),
                coordinateSync: false,
                widthHeightSync: false,
                letterSpacing: this.convertLetterSpacing(node.letterSpacing),
                contentPaddingLeft: 0,
                contentPaddingTop: 0,
                contentPaddingRight: 0,
                contentPaddingBottom: 0,
                qrCodeLevel: 0,
                textContentVerticalAlign: this.convertVerticalAlign(node.textAlignVertical),
                right: adjustedPosition.x + elementWidth,
                bottom: adjustedPosition.y + elementHeight,
                vCenter: adjustedPosition.x + elementWidth / 2,
                hCenter: adjustedPosition.y + elementHeight / 2
            },
            printElementType: {
                title: "„ÉÜ„Ç≠„Çπ„Éà",
                type: "text"
            }
        };

        // „Éï„Ç©„É≥„ÉàË®≠ÂÆö
        if (node.fontWeight >= 600) {
            element.options.fontWeight = "bold";
        }

        // „ÉÜ„Ç≠„Çπ„Éà„Ç¢„É©„Ç§„É°„É≥„Éà
        if (node.textAlignHorizontal) {
            element.options.textAlign = this.convertTextAlign(node.textAlignHorizontal);
        }

        // Ëâ≤Ë®≠ÂÆö
        if (node.fills && node.fills[0] && node.fills[0].color) {
            element.options.color = this.convertColor(node.fills[0].color);
        }

        // ËÉåÊôØËâ≤Ë®≠ÂÆö
        if (node.backgroundColor) {
            element.options.backgroundColor = node.backgroundColor;
        }

        // „Éú„Éº„ÉÄ„ÉºË®≠ÂÆö
        if (node.strokes && node.strokes.length > 0) {
            element.options.borderLeft = "solid";
            element.options.borderTop = "solid";
            element.options.borderRight = "solid";
            element.options.borderBottom = "solid";
        }

        // ÈÖçÁΩÆ„Åó„ÅüË¶ÅÁ¥†„ÅÆÊÉÖÂ†±„ÇíË®òÈå≤
        this.placedElements.push({
            x: adjustedPosition.x,
            y: adjustedPosition.y,
            width: elementWidth,
            height: elementHeight
        });

        printElements.push(element);
    }

    findNonOverlappingPosition(x, y, width, height) {
        let currentX = x;
        let currentY = y;
        const maxAttempts = 50;
        let attempt = 0;
        
        while (attempt < maxAttempts) {
            // ÁèæÂú®„ÅÆ‰ΩçÁΩÆ„ÅßÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
            const hasOverlap = this.placedElements.some(placed => 
                this.isOverlapping(currentX, currentY, width, height, placed)
            );
            
            if (!hasOverlap) {
                // Áî®Á¥ô„ÅÆÂ¢ÉÁïåÂÜÖ„Å´Âèé„Åæ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                if (currentX + width <= this.targetPaperSize.width - 10 && 
                    currentY + height <= this.targetPaperSize.height - 10 &&
                    currentX >= 10 && currentY >= 10) {
                    return { x: currentX, y: currentY };
                }
            }
            
            // ÈáçË§á„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅ‰ΩçÁΩÆ„ÇíË™øÊï¥
            if (attempt < 25) {
                // ÊúÄÂàù„ÅØÂè≥ÂÅ¥„Å´ÁßªÂãï
                currentX += width + 5;
                
                // Âè≥Á´Ø„Å´ÈÅî„Åó„Åü„Çâ‰∏ã„Å´ÁßªÂãï„Åó„Å¶Â∑¶Á´Ø„Å´Êàª„Çã
                if (currentX + width > this.targetPaperSize.width - 10) {
                    currentX = 10;
                    currentY += height + 5;
                }
            } else {
                // 25Âõû‰ª•Èôç„ÅØ„Ç∞„É™„ÉÉ„ÉâÈÖçÁΩÆ„ÇíË©¶Ë°å
                const gridSize = 20;
                const gridX = 10 + (attempt - 25) % 10 * gridSize;
                const gridY = 10 + Math.floor((attempt - 25) / 10) * gridSize;
                currentX = gridX;
                currentY = gridY;
            }
            
            attempt++;
        }
        
        // ÊúÄÁµÇÁöÑ„Å´ÈÅ©Âàá„Å™‰ΩçÁΩÆ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÂÖÉ„ÅÆ‰ΩçÁΩÆ„ÇíËøî„Åô
        return { x: Math.max(10, Math.min(x, this.targetPaperSize.width - width - 10)), 
                 y: Math.max(10, Math.min(y, this.targetPaperSize.height - height - 10)) };
    }

    isOverlapping(x1, y1, w1, h1, placed) {
        const x2 = placed.x;
        const y2 = placed.y;
        const w2 = placed.width;
        const h2 = placed.height;
        
        // 2„Å§„ÅÆÁü©ÂΩ¢„ÅåÈáçË§á„Åó„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        return !(x1 + w1 <= x2 || x2 + w2 <= x1 || y1 + h1 <= y2 || y2 + h2 <= y1);
    }

    convertImageOrShapeNode(node, printElements, absoluteX, absoluteY) {
        // ÁîªÂÉè„Å®„Åù„ÅÆ‰ªñ„ÅÆÂõ≥ÂΩ¢„ÇíÂå∫Âà•„Åó„Å¶Âá¶ÁêÜ
        const isImage = node.type === 'RECTANGLE' && node.fills && 
                       node.fills.some(fill => fill.type === 'IMAGE');
        
        if (isImage) {
            // ÁîªÂÉèË¶ÅÁ¥†„Å®„Åó„Å¶Âá¶ÁêÜ
            const element = {
                options: {
                    left: this.convertPosition(absoluteX),
                    top: this.convertPosition(absoluteY),
                    height: this.convertSize(node.height || 20),
                    width: this.convertSize(node.width || 100),
                    borderWidth: "0.75",
                    coordinateSync: false,
                    widthHeightSync: false,
                    right: this.convertPosition(absoluteX + (node.width || 100)),
                    bottom: this.convertPosition(absoluteY + (node.height || 20)),
                    vCenter: this.convertPosition(absoluteX + (node.width || 100) / 2),
                    hCenter: this.convertPosition(absoluteY + (node.height || 20) / 2),
                    fit: "contain", // ÁîªÂÉè„ÅÆ„Éï„Ç£„ÉÉ„ÉàÊñπÊ≥ï
                    src: "", // ÂÆüÈöõ„ÅÆÁîªÂÉèURL„ÅØÊâãÂãï„ÅßË®≠ÂÆö„ÅåÂøÖË¶Å
                    field: `image_${Date.now()}` // ‰∏ÄÊÑè„ÅÆ„Éï„Ç£„Éº„É´„ÉâÂêç
                },
                printElementType: {
                    title: "ÂõæÁâá",
                    type: "image"
                }
            };
            
            printElements.push(element);
        } else {
            // Âõ≥ÂΩ¢Ë¶ÅÁ¥†„ÅØ„ÉÜ„Ç≠„Çπ„ÉàË¶ÅÁ¥†„Å®„Åó„Å¶Âá¶ÁêÜÔºà„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„ÉºÔºâ
            const element = {
                options: {
                    left: this.convertPosition(absoluteX),
                    top: this.convertPosition(absoluteY),
                    height: this.convertSize(node.height || 20),
                    width: this.convertSize(node.width || 100),
                    borderWidth: "0.75",
                    fontSize: 8,
                    title: `[${node.type}] ${node.name || "Âõ≥ÂΩ¢Ë¶ÅÁ¥†"}`,
                    coordinateSync: false,
                    widthHeightSync: false,
                    letterSpacing: 0,
                    contentPaddingLeft: 2,
                    contentPaddingTop: 2,
                    contentPaddingRight: 2,
                    contentPaddingBottom: 2,
                    qrCodeLevel: 0,
                    textContentVerticalAlign: "middle",
                    textAlign: "center",
                    right: this.convertPosition(absoluteX + (node.width || 100)),
                    bottom: this.convertPosition(absoluteY + (node.height || 20)),
                    vCenter: this.convertPosition(absoluteX + (node.width || 100) / 2),
                    hCenter: this.convertPosition(absoluteY + (node.height || 20) / 2)
                },
                printElementType: {
                    title: "„ÉÜ„Ç≠„Çπ„Éà",
                    type: "text"
                }
            };

            // ËÉåÊôØËâ≤ÔºàÂõ≥ÂΩ¢Ë¶ÅÁ¥†„ÅÆ„ÅøÔºâ
            if (node.fills && node.fills[0] && node.fills[0].color) {
                element.options.backgroundColor = this.convertColor(node.fills[0].color);
            }

            // „Çπ„Éà„É≠„Éº„ÇØ
            if (node.strokes && node.strokes.length > 0) {
                element.options.borderLeft = "solid";
                element.options.borderTop = "solid";
                element.options.borderRight = "solid";
                element.options.borderBottom = "solid";
                if (node.strokes[0].color) {
                    element.options.borderColor = this.convertColor(node.strokes[0].color);
                }
            }

            printElements.push(element);
        }
    }

    convertPosition(position) {
        // Figma„ÅÆ„Éî„ÇØ„Çª„É´Â∫ßÊ®ô„ÇíeDocument„ÅÆmmÂ∫ßÊ®ô„Å´Â§âÊèõ
        // „Çà„ÇäÊ≠£Á¢∫„Å™Â§âÊèõÂºè: 1pixel ‚âà 0.264583mm (96DPIÂü∫Ê∫ñ) „ÅßÂü∫Êú¨Â§âÊèõ
        // „Åù„ÅÆÂæå„ÄÅÁî®Á¥ô„Çµ„Ç§„Ç∫„Å®„Çπ„Ç±„Éº„É´„Éï„Ç°„ÇØ„Çø„Éº„ÇíÈÅ©Áî®
        const mmPosition = position * 0.264583;
        
        // Áî®Á¥ô„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Åü„Çπ„Ç±„Éº„É™„É≥„Ç∞
        const scaleX = (this.targetPaperSize.width - 20) / (this.figmaWidth * 0.264583);
        const scaleY = (this.targetPaperSize.height - 20) / (this.figmaHeight * 0.264583);
        const scale = Math.min(scaleX, scaleY) * this.scaleFactor;
        
        const scaledPosition = mmPosition * scale;
        
        return Math.round(scaledPosition * 100) / 100 + 10; // 10mm„Éû„Éº„Ç∏„É≥ËøΩÂä†
    }

    convertSize(size) {
        // „Çµ„Ç§„Ç∫„ÅØÂü∫Êú¨ÁöÑ„Å™„Éî„ÇØ„Çª„É´‚ÜímmÂ§âÊèõ„ÅÆ„Åø„Åß„ÄÅÈÅéÂ∫¶„Å™„Çπ„Ç±„Éº„É™„É≥„Ç∞„ÅØÈÅø„Åë„Çã
        const mmSize = size * 0.264583;
        
        // ËªΩÂæÆ„Å™„Çπ„Ç±„Éº„É´Ë™øÊï¥„ÅÆ„ÅøÔºà„É¶„Éº„Ç∂„ÉºÊåáÂÆö„ÅÆ„Çπ„Ç±„Éº„É´„Éï„Ç°„ÇØ„Çø„Éº„ÅÆ„ÅøÈÅ©Áî®Ôºâ
        let scaledSize = mmSize * this.scaleFactor;
        
        // A4Áî®Á¥ô„ÅÆ„Çµ„Ç§„Ç∫Âà∂Á¥Ñ„ÇíËÄÉÊÖÆ„Åó„Åü„Çà„ÇäÈÅ©Âàá„Å™„Çµ„Ç§„Ç∫Ë™øÊï¥
        const maxWidth = this.targetPaperSize.width - 40; // 20mm„Éû„Éº„Ç∏„É≥√ó2
        const maxHeight = this.targetPaperSize.height - 60; // 30mm„Éû„Éº„Ç∏„É≥√ó2
        
        // Ê•µÁ´Ø„Å´Â§ß„Åç„ÅÑ„Çµ„Ç§„Ç∫„ÇíÂà∂Èôê
        if (scaledSize > maxWidth * 0.8) {
            scaledSize = maxWidth * 0.8;
        }
        if (scaledSize > maxHeight * 0.6) {
            scaledSize = maxHeight * 0.6;
        }
        
        // ÊúÄÂ∞è„Çµ„Ç§„Ç∫„ÇíÁ¢∫‰øùÔºàË™≠„Åø„ÇÑ„Åô„Åï„ÅÆ„Åü„ÇÅÔºâ
        const minSize = 8;
        
        return Math.max(minSize, Math.round(scaledSize * 100) / 100);
    }

    convertFontSize(fontSize) {
        // „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÅØÂÆüÁî®ÁöÑ„Å™ÁØÑÂõ≤„Å´‰øù„Å§Ôºà6-18ptÔºâ
        const ptSize = fontSize * 0.75; // „Éî„ÇØ„Çª„É´„Åã„Çâ„Éù„Ç§„É≥„Éà„Å∏„ÅÆÂü∫Êú¨Â§âÊèõ
        const scaledSize = ptSize * this.scaleFactor;
        
        // ÂÆüÁî®ÁöÑ„Å™ÁØÑÂõ≤ÂÜÖ„Å´Âà∂Èôê
        return Math.max(6, Math.min(18, Math.round(scaledSize * 100) / 100));
    }

    convertLetterSpacing(letterSpacing) {
        if (!letterSpacing || letterSpacing.unit === 'PERCENT') {
            return letterSpacing ? letterSpacing.value : 0;
        }
        return 0;
    }

    convertVerticalAlign(align) {
        const alignMap = {
            'TOP': 'top',
            'CENTER': 'middle',
            'BOTTOM': 'bottom'
        };
        return alignMap[align] || 'middle';
    }

    convertTextAlign(align) {
        const alignMap = {
            'LEFT': 'left',
            'CENTER': 'center',
            'RIGHT': 'right'
        };
        return alignMap[align] || 'left';
    }

    convertColor(colorObj) {
        if (!colorObj) return '#000000';
        
        const r = Math.round((colorObj.r || 0) * 255);
        const g = Math.round((colorObj.g || 0) * 255);
        const b = Math.round((colorObj.b || 0) * 255);
        
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    sanitizeText(text) {
        if (!text) return "";
        // ÊîπË°åÊñáÂ≠ó„ÇíÈÅ©Âàá„Å´Âá¶ÁêÜ„Åó„ÄÅHTML„Ç®„Çπ„Ç±„Éº„Éó
        return text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').substring(0, 200);
    }

    getConversionStats(eDocumentData) {
        const elements = eDocumentData.panels[0].printElements;
        const textElements = elements.filter(el => el.printElementType.type === 'text');
        const imageElements = elements.filter(el => el.printElementType.type === 'image');
        const skippedElements = this.debugInfo.filter(info => info.type === 'SKIPPED_IMAGE');
        const pathBasedElements = this.debugInfo.filter(info => info.type === 'PATH_BASED_TEXT');
        const pathNotFoundElements = this.debugInfo.filter(info => info.type === 'PATH_NOT_FOUND');
        
        return {
            totalElements: elements.length,
            textElements: textElements.length,
            imageElements: imageElements.length,
            skippedElements: skippedElements.length,
            pathBasedElements: pathBasedElements.length,
            pathNotFoundElements: pathNotFoundElements.length,
            paperSize: eDocumentData.panels[0].paperType,
            paperWidth: eDocumentData.panels[0].width,
            paperHeight: eDocumentData.panels[0].height
        };
    }
}

// „Ç∞„É≠„Éº„Éê„É´„Å´ÂÖ¨Èñã
window.FigmaToEDocumentConverter = FigmaToEDocumentConverter;